// Declarative Pipeline for CI/CD Demo Application
pipeline {
    agent any
    
    environment {
        // Docker registry credentials (configure in Jenkins)
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'jenkins-demo-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        
        // Application versioning
        APP_VERSION = '1.0.0'
        GIT_COMMIT_SHORT = "${GIT_COMMIT?.take(7)}"
    }
    
    options {
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo 'Checking out source code...'
                checkout scm
                
                script {
                    // Get git information
                    env.GIT_COMMIT = sh(returnStdout: true, script: 'git rev-parse HEAD').trim()
                    env.GIT_BRANCH = sh(returnStdout: true, script: 'git rev-parse --abbrev-ref HEAD').trim()
                }
                
                echo "Branch: ${env.GIT_BRANCH}"
                echo "Commit: ${env.GIT_COMMIT}"
            }
        }
        
        stage('Setup') {
            steps {
                echo 'Setting up Python environment...'
                sh '''
                    python3 --version
                    pip3 install --user virtualenv
                    python3 -m virtualenv venv
                    . venv/bin/activate
                    pip install -r src/requirements.txt
                    pip install -r tests/requirements-test.txt
                '''
            }
        }
        
        stage('Lint') {
            steps {
                echo 'Running code quality checks...'
                sh '''
                    . venv/bin/activate
                    pip install flake8 pylint
                    
                    # Run flake8
                    flake8 src/ --max-line-length=120 --exclude=venv || true
                    
                    # Run pylint
                    pylint src/app.py --exit-zero
                '''
            }
        }
        
        stage('Test') {
            steps {
                echo 'Running unit tests...'
                sh '''
                    . venv/bin/activate
                    python -m pytest tests/ -v --junitxml=test-results.xml --cov=src --cov-report=xml
                '''
            }
            post {
                always {
                    junit 'test-results.xml'
                    publishHTML target: [
                        allowMissing: true,
                        alwaysLinkToLastBuild: false,
                        keepAll: true,
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ]
                }
            }
        }
        
        stage('Security Scan') {
            steps {
                echo 'Running security scans...'
                sh '''
                    . venv/bin/activate
                    pip install safety bandit
                    
                    # Check for known vulnerabilities
                    safety check --json || true
                    
                    # Static security analysis
                    bandit -r src/ -f json -o bandit-report.json || true
                '''
            }
        }
        
        stage('Build Docker Image') {
            steps {
                echo 'Building Docker image...'
                script {
                    docker.build("${DOCKER_IMAGE}:${DOCKER_TAG}", 
                        "--build-arg BUILD_NUMBER=${BUILD_NUMBER} " +
                        "--build-arg GIT_COMMIT=${GIT_COMMIT} " +
                        "--build-arg APP_VERSION=${APP_VERSION} " +
                        ".")
                }
            }
        }
        
        stage('Test Docker Image') {
            steps {
                echo 'Testing Docker image...'
                script {
                    // Run container for testing
                    sh """
                        docker run -d --name test-container -p 5001:5000 ${DOCKER_IMAGE}:${DOCKER_TAG}
                        sleep 5
                        
                        # Test endpoints
                        curl -f http://localhost:5001/health || exit 1
                        curl -f http://localhost:5001/ready || exit 1
                        curl -f http://localhost:5001/ || exit 1
                        
                        # Cleanup
                        docker stop test-container
                        docker rm test-container
                    """
                }
            }
        }
        
        stage('Push to Registry') {
            when {
                branch 'main'
            }
            steps {
                echo 'Pushing Docker image to registry...'
                script {
                    // This requires Docker Hub credentials configured in Jenkins
                    // docker.withRegistry('https://registry.hub.docker.com', 'docker-hub-credentials') {
                    //     docker.image("${DOCKER_IMAGE}:${DOCKER_TAG}").push()
                    //     docker.image("${DOCKER_IMAGE}:${DOCKER_TAG}").push('latest')
                    // }
                    
                    // For lab, just tag as latest
                    sh "docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${DOCKER_IMAGE}:latest"
                }
            }
        }
        
        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                echo 'Deploying to staging environment...'
                sh '''
                    # Stop existing container if running
                    docker stop staging-app || true
                    docker rm staging-app || true
                    
                    # Run new container
                    docker run -d \
                        --name staging-app \
                        -p 5002:5000 \
                        -e ENVIRONMENT=staging \
                        --restart unless-stopped \
                        ${DOCKER_IMAGE}:${DOCKER_TAG}
                    
                    # Wait for health check
                    sleep 10
                    curl -f http://localhost:5002/health || exit 1
                '''
            }
        }
        
        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            input {
                message "Deploy to production?"
                ok "Yes, deploy to production"
            }
            steps {
                echo 'Deploying to production environment...'
                sh '''
                    # Blue-Green Deployment
                    # Deploy new version as blue
                    docker stop prod-app-blue || true
                    docker rm prod-app-blue || true
                    
                    docker run -d \
                        --name prod-app-blue \
                        -p 5003:5000 \
                        -e ENVIRONMENT=production \
                        --restart unless-stopped \
                        ${DOCKER_IMAGE}:${DOCKER_TAG}
                    
                    # Health check
                    sleep 10
                    curl -f http://localhost:5003/health || exit 1
                    
                    # Switch traffic (in real scenario, update load balancer)
                    docker stop prod-app-green || true
                    docker rm prod-app-green || true
                    docker rename prod-app-blue prod-app-green
                    
                    echo "Production deployment complete!"
                '''
            }
        }
    }
    
    post {
        always {
            echo 'Cleaning up workspace...'
            sh '''
                # Clean up test artifacts
                rm -rf venv
                rm -f test-results.xml coverage.xml
                
                # Clean up Docker
                docker image prune -f || true
            '''
        }
        
        success {
            echo 'Pipeline completed successfully!'
            // Send success notification
            // slackSend(channel: '#ci-cd', message: "Build Successful: ${env.JOB_NAME} - ${env.BUILD_NUMBER}")
        }
        
        failure {
            echo 'Pipeline failed!'
            // Send failure notification
            // slackSend(channel: '#ci-cd', message: "Build Failed: ${env.JOB_NAME} - ${env.BUILD_NUMBER}")
        }
        
        unstable {
            echo 'Pipeline is unstable'
        }
    }
}
